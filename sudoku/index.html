<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sudoku — Full Featured</title>
  <style>
    :root{--cell-size:48px;--gap:4px;--accent:#0ea5a4;--bg:#0f172a;--card:#0b1220;--muted:#94a3b8}
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071129 0%, #071827 100%);color:#e6eef6}
    .app{max-width:980px;margin:28px auto;padding:20px}
    .top{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    h1{margin:0;font-size:20px}

    .controls{display:flex;gap:8px;margin-left:auto;flex-wrap:wrap}
    button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.primary{background:linear-gradient(90deg,var(--accent),#60a5fa);color:#001}
    .board-wrap{display:flex;gap:20px;margin-top:16px}
    .board{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    .grid{display:grid;grid-template-columns:repeat(9, var(--cell-size));grid-gap:var(--gap)}
    .cell{width:var(--cell-size);height:var(--cell-size);display:flex;align-items:center;justify-content:center;border-radius:6px;font-weight:600;font-size:18px;position:relative;user-select:none}
    .cell input{position:absolute;inset:0;border:0;background:transparent;color:inherit;font-weight:600;font-size:18px;text-align:center}
    .cell.small{font-weight:500;font-size:11px}
    .givencell{color:var(--bg);background:linear-gradient(180deg,#ffffff,#e6eef6);}
    .selected{outline:3px solid rgba(14,165,164,0.15);box-shadow:0 8px 24px rgba(2,6,23,0.5) inset}
    .conflict{background:linear-gradient(90deg,#4c1e1e,#7f1d1d);color:#ffecec}
    .highlight{background:rgba(236,252,255,0.04)}
    .thick-right{border-right:3px solid rgba(255,255,255,0.06)}
    .thick-bottom{border-bottom:3px solid rgba(255,255,255,0.06)}
    .side{flex:1;min-width:240px}
    .panel{background:linear-gradient(180deg,#061226,#07122b);padding:12px;border-radius:10px}
    .note{font-size:13px;color:var(--muted)}
    .num-row{display:flex;gap:6px;margin-top:10px}
    .num-row button{width:40px;height:40px;border-radius:8px;font-size:16px}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .small{font-size:12px;padding:6px 8px}
    .status{margin-top:10px;font-size:13px;color:var(--muted)}
    .pencil{font-size:10px;line-height:1;display:flex;flex-wrap:wrap;gap:2px}
    .pencil span{width:14px;height:14px;display:inline-flex;align-items:center;justify-content:center;border-radius:2px;background:rgba(255,255,255,0.02)}
    .footer{margin-top:18px;color:var(--muted);font-size:13px}
    @media(max-width:880px){.board-wrap{flex-direction:column}.controls{margin-left:0}}
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <h1>Sudoku — Full-featured (9×9)</h1>
      <div class="controls">
        <select id="difficulty"><option>Easy</option><option selected>Medium</option><option>Hard</option><option>Expert</option></select>
        <button id="newBtn" class="primary">New Puzzle</button>
        <button id="solveBtn">Solve</button>
        <button id="hintBtn">Hint</button>
        <button id="checkBtn">Check</button>
        <button id="exportBtn">Export</button>
        <button id="importBtn">Import</button>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board" id="board">
        <div class="grid" id="grid"></div>
      </div>

      <div class="side">
        <div class="panel">
          <div><strong>Controls</strong></div>
          <div class="note">Use mouse or keyboard (1–9). Press <kbd>0</kbd> or <kbd>Backspace</kbd> to clear. Toggle Pencil (notes) mode to add small candidates.</div>
          <div class="toolbar">
            <button id="pencilBtn">Pencil: Off</button>
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
            <button id="validateBtn">Validate</button>
            <button id="printBtn">Print</button>
            <button id="resetBtn">Reset</button>
          </div>

          <div class="num-row" id="numRow">
            <!-- number buttons inserted here -->
          </div>

          <div class="status" id="status">Status: Ready</div>

          <div style="margin-top:12px"><strong>Timer</strong>
            <div id="timer">00:00</div>
          </div>

          <div class="footer">Hints cost 1 point. You can export current state as JSON and import it back.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // === Sudoku engine: solver/generator/board management ===
  (function(){
    // utilities
    const $ = (id)=>document.getElementById(id);
    const gridEl = $('grid');
    let solution = []; // 9x9 completed solution
    let puzzle = []; // current puzzle with zeros
    let given = []; // boolean is given
    let pencilMode=false;
    let notes = Array.from({length:9},()=>Array.from({length:9},()=>new Set()));
    let undoStack = [], redoStack = [];
    let timerInterval=null, seconds=0, started=false;

    function startTimer(){ if(timerInterval) clearInterval(timerInterval); started=true; timerInterval=setInterval(()=>{seconds++; $('timer').textContent=formatTime(seconds)},1000)}
    function stopTimer(){ if(timerInterval) clearInterval(timerInterval); timerInterval=null}
    function resetTimer(){ stopTimer(); seconds=0; started=false; $('timer').textContent='00:00' }
    function formatTime(s){ const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${mm}:${ss}` }

    // shuffle utility (top-level so all functions can use it)
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }

    // generate full solved board using backtracking
    function generateSolution(){
      const board = Array.from({length:9},()=>Array(9).fill(0));
      const rows=Array.from({length:9},()=>new Set());
      const cols=Array.from({length:9},()=>new Set());
      const boxes=Array.from({length:9},()=>new Set());
      const nums=[1,2,3,4,5,6,7,8,9];

      function boxIndex(r,c){return Math.floor(r/3)*3+Math.floor(c/3)}

      function backtrack(pos=0){
        if(pos===81) return true;
        const r=Math.floor(pos/9), c=pos%9;
        const choices=shuffle(nums.slice());
        for(const n of choices){
          if(rows[r].has(n) || cols[c].has(n) || boxes[boxIndex(r,c)].has(n)) continue;
          board[r][c]=n; rows[r].add(n); cols[c].add(n); boxes[boxIndex(r,c)].add(n);
          if(backtrack(pos+1)) return true;
          board[r][c]=0; rows[r].delete(n); cols[c].delete(n); boxes[boxIndex(r,c)].delete(n);
        }
        return false;
      }
      backtrack();
      return board;
    }

    // remove numbers to create puzzle of appropriate difficulty
    function digFromSolution(sol,difficulty){
      // copy
      const p = sol.map(r=>r.slice());
      const attempts = {Easy:36, Medium:46, Hard:52, Expert:56}[difficulty]||46; // numbers to remove (approx)
      let removed=0; const positions=[]; for(let r=0;r<9;r++)for(let c=0;c<9;c++)positions.push([r,c]);
      shuffle(positions);
      let tries=0;
      for(const [r,c] of positions){
        if(removed>=attempts) break;
        const backup = p[r][c]; p[r][c]=0;
        // check unique solution by counting up to 2
        let count=0;
        function countSolutions(b,pos=0){
          if(count>1) return; if(pos===81){count++; return}
          const rr=Math.floor(pos/9), cc=pos%9;
          if(b[rr][cc]!==0){countSolutions(b,pos+1);return}
          for(let n=1;n<=9;n++){
            if(validPlacement(b,rr,cc,n)){
              b[rr][cc]=n; countSolutions(b,pos+1); b[rr][cc]=0;
              if(count>1) return;
            }
          }
        }
        countSolutions(p.map(r=>r.slice()));
        if(count===1){ removed++; } else { p[r][c]=backup }
        tries++; if(tries>500) break;
      }
      return p;
    }

    function validPlacement(b,r,c,n){
      for(let i=0;i<9;i++){ if(b[r][i]===n) return false; if(b[i][c]===n) return false }
      const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
      for(let rr=br;rr<br+3;rr++) for(let cc=bc;cc<bc+3;cc++) if(b[rr][cc]===n) return false;
      return true;
    }

    // solver (backtracking) to fill board (works on array copy)
    function solveBoard(b){
      const board = b.map(r=>r.slice());
      function backtrack(){
        let minR=-1,minC=-1,minChoices=10;
        for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(board[r][c]===0){
          const choices=[]; for(let n=1;n<=9;n++) if(validPlacement(board,r,c,n)) choices.push(n);
          if(choices.length===0) return false;
          if(choices.length<minChoices){minChoices=choices.length;minR=r;minC=c}
        }
        if(minR===-1) return true; // solved
        for(let n=1;n<=9;n++){
          if(!validPlacement(board,minR,minC,n)) continue;
          board[minR][minC]=n;
          if(backtrack()) return true;
          board[minR][minC]=0;
        }
        return false;
      }
      const ok = backtrack();
      return ok?board:null;
    }

    // === UI: build grid ===
    function buildGrid(){
      gridEl.innerHTML='';
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          const cell = document.createElement('div'); cell.className='cell';
          if(c%3===2) cell.classList.add('thick-right'); if(r%3===2) cell.classList.add('thick-bottom');
          cell.dataset.r=r; cell.dataset.c=c;
          const input=document.createElement('input'); input.type='text'; input.maxLength=1; input.autocomplete='off'; input.inputMode='numeric';
          input.addEventListener('focus', ()=>onSelect(r,c));
          input.addEventListener('keydown', onKeyDown);
          input.addEventListener('input', onInput);
          cell.appendChild(input);
          const pencil = document.createElement('div'); pencil.className='pencil'; pencil.style.display='none';
          for(let n=1;n<=9;n++){ const s=document.createElement('span'); s.textContent=n; pencil.appendChild(s) }
          cell.appendChild(pencil);
          gridEl.appendChild(cell);
        }
      }
    }

    function cellEl(r,c){ return gridEl.children[r*9+c] }

    function render(){
      for(let r=0;r<9;r++) for(let c=0;c<9;c++){
        const el = cellEl(r,c); const input = el.querySelector('input'); const pencil = el.querySelector('.pencil');
        if(given[r][c]){ el.classList.add('givencell'); input.value = puzzle[r][c]||''; input.disabled=true; pencil.style.display='none'; }
        else { el.classList.remove('givencell'); input.disabled=false; input.value = puzzle[r][c]||''; pencil.style.display = (pencilMode && notes[r][c].size)? 'flex':'none'; if(pencilMode){ // show candidates
            el.classList.toggle('small',true);
            for(let n=1;n<=9;n++){ pencil.children[n-1].style.opacity = notes[r][c].has(n)?'1':'0.18' }
          } else el.classList.toggle('small',false);
        }
        el.classList.toggle('conflict',false); el.classList.toggle('highlight',false); el.classList.toggle('selected',false);
      }
    }

    // selection
    let sel = {r:null,c:null};
    function onSelect(r,c){ sel={r,c}; updateHighlights(); }
    function updateHighlights(){ if(sel.r===null) return; for(let r=0;r<9;r++) for(let c=0;c<9;c++){ const el=cellEl(r,c); el.classList.toggle('highlight', r===sel.r||c===sel.c || (Math.floor(r/3)===Math.floor(sel.r/3) && Math.floor(c/3)===Math.floor(sel.c/3)) ); el.classList.toggle('selected', r===sel.r && c===sel.c); } }

    // input handlers
    function onKeyDown(e){ const r=+this.parentElement.dataset.r, c=+this.parentElement.dataset.c; const key=e.key;
      if(key==='ArrowLeft'){ focusCell(r,c-1); e.preventDefault(); return }
      if(key==='ArrowRight'){ focusCell(r,c+1); e.preventDefault(); return }
      if(key==='ArrowUp'){ focusCell(r-1,c); e.preventDefault(); return }
      if(key==='ArrowDown'){ focusCell(r+1,c); e.preventDefault(); return }
      if(key==='Backspace' || key==='0' || key==='Delete'){ commitValue(r,c,0); e.preventDefault(); return }
      if(/^[1-9]$/.test(key)){ commitValue(r,c,Number(key)); e.preventDefault(); return }
    }
    function onInput(e){ const val = e.target.value.replace(/[^1-9]/g,''); e.target.value=val; const r=+this.parentElement.dataset.r,c=+this.parentElement.dataset.c; if(val==='') commitValue(r,c,0); else commitValue(r,c,Number(val)); }

    function focusCell(r,c){ if(r<0||r>8||c<0||c>8) return; const el=cellEl(r,c); el.querySelector('input').focus(); }

    function commitValue(r,c,val){ if(given[r][c]) return; pushUndo(); redoStack=[]; // clear redo on new action
      if(pencilMode && val!==0){ // toggle note
        if(notes[r][c].has(val)) notes[r][c].delete(val); else notes[r][c].add(val);
        puzzle[r][c]=0; render(); return;
      }
      notes[r][c].clear(); puzzle[r][c]=val; render(); checkConflicts(); startTimerIfNeeded(); }

    function pushUndo(){ undoStack.push({puzzle:copyBoard(puzzle),notes:notes.map(row=>row.map(s=>new Set([...s])))}); if(undoStack.length>200) undoStack.shift(); }
    function doUndo(){ if(undoStack.length===0) return; redoStack.push({puzzle:copyBoard(puzzle),notes:notes.map(row=>row.map(s=>new Set([...s])))}); const last=undoStack.pop(); puzzle=last.puzzle; notes=last.notes; render(); }
    function doRedo(){ if(redoStack.length===0) return; undoStack.push({puzzle:copyBoard(puzzle),notes:notes.map(row=>row.map(s=>new Set([...s])))}); const next=redoStack.pop(); puzzle=next.puzzle; notes=next.notes; render(); }

    function copyBoard(b){ return b.map(r=>r.slice()) }

    function checkConflicts(){ // mark any conflicts
      for(let r=0;r<9;r++) for(let c=0;c<9;c++){
        const el=cellEl(r,c); el.classList.toggle('conflict',false);
      }
      for(let r=0;r<9;r++) for(let c=0;c<9;c++){
        const val=puzzle[r][c]; if(val===0) continue;
        for(let i=0;i<9;i++){ if(i!==c && puzzle[r][i]===val){ cellEl(r,i).classList.add('conflict'); cellEl(r,c).classList.add('conflict') } if(i!==r && puzzle[i][c]===val){ cellEl(i,c).classList.add('conflict'); cellEl(r,c).classList.add('conflict') } }
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3; for(let rr=br;rr<br+3;rr++) for(let cc=bc;cc<bc+3;cc++){ if((rr!==r||cc!==c) && puzzle[rr][cc]===val){ cellEl(rr,cc).classList.add('conflict'); cellEl(r,c).classList.add('conflict') } }
      }
    }

    function startTimerIfNeeded(){ if(!started) startTimer(); }

    // public actions
    function newPuzzle(difficulty='Medium'){
      resetTimer(); undoStack=[]; redoStack=[]; notes = Array.from({length:9},()=>Array.from({length:9},()=>new Set()));
      solution = generateSolution(); puzzle = digFromSolution(solution,difficulty); given = Array.from({length:9},(_,r)=>Array.from({length:9},(_,c)=>puzzle[r][c]!==0)); render(); checkConflicts(); $('status').textContent='Status: New puzzle ('+difficulty+')';
    }

    function solveCurrent(){ const solved = solveBoard(puzzle.map(r=>r.slice())); if(solved){ puzzle = solved; render(); $('status').textContent='Status: Solved'; stopTimer(); } else { $('status').textContent='Status: No solution'; } }

    function hint(){ // fill one empty cell with correct value from solution
      // try to find a cell with 0
      if(!solution || solution.length===0){ $('status').textContent='Status: No solution available for hint'; return }
      for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(!given[r][c] && puzzle[r][c]===0){ pushUndo(); puzzle[r][c]=solution[r][c]; render(); checkConflicts(); $('status').textContent='Status: Hint placed at '+(r+1)+','+(c+1); startTimerIfNeeded(); return }
      $('status').textContent='Status: Nothing to hint';
    }

    function validate(){ // check if board currently valid (no conflicts and all filled)
      checkConflicts(); const conflicts = [...gridEl.querySelectorAll('.conflict')]; if(conflicts.length>0){ $('status').textContent='Status: Found conflicts'; return false; }
      for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(puzzle[r][c]===0){ $('status').textContent='Status: Incomplete'; return false }
      $('status').textContent='Status: Correct! Completed puzzle.'; return true;
    }

    function exportState(){ const state={puzzle,solution,given,notes:notes.map(r=>r.map(s=>[...s])),seconds}; const txt=JSON.stringify(state); const blob=new Blob([txt],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='sudoku_state.json'; a.click(); URL.revokeObjectURL(url); }
    function importState(){ const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange=(e)=>{ const f=e.target.files[0]; const reader=new FileReader(); reader.onload=(ev)=>{ try{ const obj=JSON.parse(ev.target.result); if(obj.puzzle){ puzzle=obj.puzzle; solution=obj.solution||generateSolution(); given=obj.given||puzzle.map(r=>r.map(c=>c!==0)); notes = Array.from({length:9},(_,r)=>Array.from({length:9},(_,c)=>new Set((obj.notes?.[r]?.[c])||[]))); render(); $('status').textContent='Status: Imported'; }else alert('Invalid file'); }catch(er){alert('Invalid JSON')} }; reader.readAsText(f); }; inp.click(); }

    function resetToGiven(){ pushUndo(); for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(!given[r][c]) puzzle[r][c]=0; notes=Array.from({length:9},()=>Array.from({length:9},()=>new Set())); render(); $('status').textContent='Status: Reset to given'; }

    // build number pad
    function buildNumPad(){ const nr=$('numRow'); nr.innerHTML=''; for(let n=1;n<=9;n++){ const btn=document.createElement('button'); btn.textContent=n; btn.addEventListener('click',()=>{ if(sel.r===null) return; commitValue(sel.r,sel.c,n); }); nr.appendChild(btn); } const clr=document.createElement('button'); clr.textContent='Clear'; clr.addEventListener('click',()=>{ if(sel.r===null) return; commitValue(sel.r,sel.c,0); }); nr.appendChild(clr); }

    // wire buttons
    $('newBtn').addEventListener('click',()=>{ newPuzzle($('difficulty').value) });
    $('solveBtn').addEventListener('click', ()=>{ pushUndo(); solveCurrent(); });
    $('hintBtn').addEventListener('click', ()=> hint());
    $('checkBtn').addEventListener('click', ()=> validate());
    $('pencilBtn').addEventListener('click', ()=>{ pencilMode=!pencilMode; $('pencilBtn').textContent = 'Pencil: '+(pencilMode? 'On':'Off'); render(); });
    $('undoBtn').addEventListener('click', ()=> doUndo());
    $('redoBtn').addEventListener('click', ()=> doRedo());
    $('validateBtn').addEventListener('click', ()=> validate());
    $('exportBtn').addEventListener('click', ()=> exportState());
    $('importBtn').addEventListener('click', ()=> importState());
    $('resetBtn').addEventListener('click', ()=> resetToGiven());
    $('printBtn').addEventListener('click', ()=> window.print());

    // keyboard global shortcuts
    document.addEventListener('keydown', (e)=>{
      if(e.key==='p' && (e.ctrlKey||e.metaKey)) { e.preventDefault(); pencilMode=!pencilMode; $('pencilBtn').textContent='Pencil: '+(pencilMode?'On':'Off'); render(); }
      if(e.key==='z' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); doUndo(); }
      if(e.key==='y' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); doRedo(); }
      if(e.key==='s' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); exportState(); }
    });

    // initial setup
    buildGrid(); buildNumPad(); newPuzzle('Medium');

    // expose some debug to window (nice for testing)
    window.sudoku={newPuzzle,solveCurrent,validate,exportState,importState};

  })();
  </script>
</body>
</html>
