<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SpiderSwing — 2D Web Swinging Sidescroller</title>
  <style>
    :root{--bg:#0b1220;--sky:#0e1a2b;--accent:#ff3b3b}
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial;color:#ddd}
    #game{display:block;width:100%;height:100vh;background:linear-gradient(#0b1624,#07121a)}
    .ui{position:fixed;left:12px;top:12px;background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:10px;font-size:13px}
    .footer{position:fixed;right:12px;top:12px;background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:10px;font-size:13px}
    a{color:#8fd3ff}
    button{background:#fff2;border-radius:6px;padding:6px 10px;border:1px solid rgba(255,255,255,0.06)}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="ui">Click / Tap to shoot web. Space to release. A / D to pump swing. </div>
  <div class="footer">Made for you — open in browser and play</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width = innerWidth;
  let H = canvas.height = innerHeight;

  // handle resize
  addEventListener('resize', () => { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

  // world parameters
  const GRAV = 2000; // px/s^2
  const TIME_STEP = 1/60;

  // Camera
  let camX = 0;

  // Buildings generation
  const SEGMENT_WIDTH = 200;
  const BUILDING_GAP = 40;
  const BUILDING_MIN = 120;
  const BUILDING_MAX = H - 180;
  const seed = (x) => { // simple pseudo-random
    return Math.abs(Math.sin(x*123.4567))*10000 % 1;
  }
  function getBuildingAt(i){
    // Procedural heights
    const h = BUILDING_MIN + (seed(i*1.37)+0.2)* (BUILDING_MAX-BUILDING_MIN);
    return {x: i*(SEGMENT_WIDTH+BUILDING_GAP), w: SEGMENT_WIDTH, h: Math.floor(h)};
  }

  // player
  const player = {
    x: 100,
    y: H/2 - 50,
    vx: 0,
    vy: 0,
    r: 16,
    onGround: false,
  };

  // rope / web state
  let rope = {
    attached: false,
    ax: 0, ay:0, // anchor
    length: 0,
  };

  // input
  const keys = {};
  addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key === ' ') e.preventDefault(); });
  addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // mouse / touch to attach
  let pointer = {x:0,y:0};
  canvas.addEventListener('pointerdown', (ev)=>{
    pointer.x = ev.clientX; pointer.y = ev.clientY;
    shootWeb(pointer.x + camX, pointer.y);
  });

  function worldToScreen(x){ return x - camX; }

  function shootWeb(wx, wy){
    // find nearest building rooftop point within range
    const maxRange = 900;
    let best = null;
    const leftIndex = Math.floor((wx - 200)/(SEGMENT_WIDTH+BUILDING_GAP)) - 2;
    for(let i = leftIndex; i < leftIndex + 30; i++){
      if(i<0) continue;
      const b = getBuildingAt(i);
      const bx = b.x + b.w/2;
      const by = H - b.h;
      const dx = bx - wx; const dy = by - wy;
      const dist = Math.hypot(dx,dy);
      if(dist <= maxRange){
        if(!best || dist < best.dist) best = {i, bx, by, dist};
      }
    }
    if(best){
      rope.attached = true;
      rope.ax = best.bx;
      rope.ay = best.by;
      rope.length = Math.hypot(player.x - rope.ax, player.y - rope.ay);
      // small slack so it doesn't jitter into the anchor instantly
    }
  }

  function releaseWeb(){ rope.attached = false; }

  // physics update
  function step(dt){
    // integrate gravity
    player.vy += GRAV * dt;
    // simple air drag
    player.vx *= 0.999;
    player.vy *= 0.999;

    // tangential pumping when attached
    if(rope.attached){
      // compute vector from anchor to player
      let dx = player.x - rope.ax;
      let dy = player.y - rope.ay;
      const dist = Math.hypot(dx,dy);
      // enforce length constraint
      const nrmx = dx/dist, nrmy = dy/dist;

      // correct position to satisfy rope length (project to circle)
      const desiredX = rope.ax + nrmx * rope.length;
      const desiredY = rope.ay + nrmy * rope.length;
      // apply velocity correction based on correction vector
      player.x = desiredX;
      player.y = desiredY;

      // compute tangential direction (perpendicular)
      const tangx = -nrmy, tangy = nrmx; // rotate by 90deg
      // compute current tangential speed
      const tangSpeed = player.vx * tangx + player.vy * tangy;

      // pumping: A (left) negative, D (right) positive
      let pump = 0;
      if(keys['a']) pump = -1;
      if(keys['d']) pump = 1;
      // apply impulse in tangential direction to gain swing
      const pumpForce = pump * 4000; // tune
      player.vx += (tangx * pumpForce) * dt;
      player.vy += (tangy * pumpForce) * dt;

      // approximate centripetal correction: remove radial velocity
      const radialVel = player.vx * nrmx + player.vy * nrmy;
      player.vx -= radialVel * nrmx;
      player.vy -= radialVel * nrmy;

      // apply gravity along tangent by projecting gravity onto tangent
      player.vx += tangx * (GRAV * dt * 0.0); // optional small effect
    } else {
      // normal freefall horizontal movement friction
      player.x += player.vx * dt;
      player.y += player.vy * dt;
    }

    // If attached, update position from velocity (tangential velocity preserved)
    if(rope.attached){
      player.x += player.vx * dt;
      player.y += player.vy * dt;
    }

    // ground collision with buildings
    // check which building below player
    const idx = Math.floor(player.x / (SEGMENT_WIDTH+BUILDING_GAP));
    const b = getBuildingAt(idx);
    if(b){
      const groundY = H - b.h;
      // if player inside building horizontally? allow small overlap
      const within = player.x > b.x - 2 && player.x < b.x + b.w + 2;
      if(within && player.y + player.r > groundY){
        player.y = groundY - player.r;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }
    }

    // camera follows player smoothly
    const targetCam = player.x - W*0.35;
    camX += (targetCam - camX) * 0.12;

    // keep player roughly within world bounds
    if(player.y > H + 200) { // fell off
      // respawn
      player.x = Math.max(100, camX + 100);
      player.y = H/2 - 50;
      player.vx = 0; player.vy = 0;
      releaseWeb();
    }
  }

  // release on space
  addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){
      releaseWeb();
    }
  });

  // simple collision for attaching to the side walls — allow hooking to building edges
  // rendering
  function draw(){
    // clear
    ctx.clearRect(0,0,W,H);

    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#091426'); g.addColorStop(1,'#04101a');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // draw buildings near camera
    const firstIndex = Math.floor(camX / (SEGMENT_WIDTH+BUILDING_GAP)) - 3;
    for(let i = firstIndex; i < firstIndex + 40; i++){
      if(i<0) continue;
      const b = getBuildingAt(i);
      const sx = Math.floor(b.x - camX);
      const sy = Math.floor(H - b.h);
      // building body
      ctx.fillStyle = '#223b4f';
      ctx.fillRect(sx, sy, b.w, b.h);
      // windows pattern
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      for(let y = sy+12; y < H-12; y+=26){
        for(let x = sx+12; x < sx + b.w - 12; x+=28){
          if(Math.random() < 0.5) ctx.fillRect(x, y, 14, 10);
        }
      }
      // rooftop highlight
      ctx.fillStyle = '#152936';
      ctx.fillRect(sx, sy-6, b.w, 6);
    }

    // draw rope
    if(rope.attached){
      ctx.beginPath();
      ctx.moveTo(worldToScreen(rope.ax), rope.ay);
      ctx.lineTo(worldToScreen(player.x), player.y);
      ctx.strokeStyle = '#bfe8ff';
      ctx.lineWidth = 2;
      ctx.stroke();
      // anchor point
      ctx.beginPath(); ctx.arc(worldToScreen(rope.ax), rope.ay, 6, 0, Math.PI*2);
      ctx.fillStyle = '#88d0ff'; ctx.fill();
    }

    // draw player
    ctx.save();
    ctx.translate(worldToScreen(player.x), player.y);
    // body shadow
    ctx.beginPath(); ctx.arc(0,0,player.r+2,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fill();
    // hero
    ctx.beginPath(); ctx.arc(0,0,player.r,0,Math.PI*2);
    ctx.fillStyle = '#ff3b3b'; ctx.fill();
    // eyes / mask lines
    ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-6,-4); ctx.lineTo(0,-2); ctx.lineTo(6,-4); ctx.stroke();
    ctx.restore();

    // HUD
    ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '14px Arial';
    ctx.fillText('Position: ' + Math.round(player.x) + ',' + Math.round(player.y), 14, H-48);
    ctx.fillText('Speed: ' + Math.round(Math.hypot(player.vx, player.vy)), 14, H-28);
  }

  // main loop with fixed timestep integration
  let acc = 0; let last = performance.now()/1000;
  function frame(now){
    now = now/1000;
    let dt = now - last; if(dt > 0.1) dt = 0.1;
    last = now;
    acc += dt;
    while(acc >= TIME_STEP){ step(TIME_STEP); acc -= TIME_STEP; }
    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // touch/keyboard hints: allow mouse to drag anchor while attached
  let dragging = false;
  canvas.addEventListener('pointermove', (e)=>{ pointer.x = e.clientX; pointer.y = e.clientY; if(dragging && rope.attached){ rope.ax = pointer.x + camX; rope.ay = pointer.y; rope.length = Math.hypot(player.x - rope.ax, player.y - rope.ay); } });
  canvas.addEventListener('pointerdown', ()=>{ if(rope.attached) dragging = true; });
  canvas.addEventListener('pointerup', ()=>{ dragging = false; });

  // allow jump from ground
  addEventListener('keydown', (e)=>{ if(e.key === 'w' || e.key === 'ArrowUp'){ if(player.onGround){ player.vy = -900; player.onGround = false; } }});

  // small helpful instructions in console
  console.log('SpiderSwing loaded. Controls:\n- Click/Tap to shoot a web to nearest building rooftop in range\n- Space to release web\n- A/D to pump swing and gain momentum\n- W / Up arrow to jump when on ground');
})();
</script>
</body>
</html>
